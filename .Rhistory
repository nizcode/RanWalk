print(walks)
}
walk2(20,seed =9)
walk2(20,seed =19)
#Question 1
#Has the destination [1,-3] reached after walking a 100 roads? returns a vector of Bool, as destination might have been reached twice.
TRUE%in%Destination(as.integer(c(-1,3)),100,seed = 19) #yes destination has been reached
Rcpp::sourceCpp("ranwalk.cpp")
walk2(20,seed =19)
walk2(20,seed =19)
#Question2
yes20 = rep(0,1000) #stores 1 if reached wihin 20 and 0 if not
for(i in 1:1000){
walks = Destination(as.integer(c(1,-3)),20,seed = i)
#
if(TRUE%in%walks){
yes20[i] = 1
}
}
sum(yes20)/1000
Rcpp::sourceCpp("ranwalk.cpp")
yes20 = rep(0,1000) #stores 1 if reached wihin 20 and 0 if not
for(i in 1:1000){
walks = Destination(as.integer(c(1,-3)),20,seed = i)
#
if(TRUE%in%walks){
yes20[i] = 1
}
}
sum(yes20)/1000
Rcpp::sourceCpp("ranwalk.cpp")
for(i in 1:1000){
walks = Destination(as.integer(c(1,-3)),20,seed = i)
#
if(TRUE%in%walks){
yes20[i] = 1
}
}
sum(yes20)/1000
#pr
#This looks like at the walk function
walk(11,seed = 20)
walk2(20,seed =19)
#This looks like at the walk function
walk(11,seed = 20)
walk2(20,seed =19)
1+-2
Rcpp::sourceCpp("ranwalk.cpp")
walk2(20,seed =19)
Rcpp::sourceCpp("ranwalk.cpp")
walk2(20,seed =19)
for(i in 1:1000){
w=walk2(100,seed=i)
p1(p1,sum(which(w==0)))
p2(p2,sum(which(w==1)))
p3(p3,sum(which(w==2)))
}
p1=c()
p2=c()
p3=c()
for(i in 1:1000){
w=walk2(100,seed=i)
p1(p1,sum(which(w==0)))
p2(p2,sum(which(w==1)))
p3(p3,sum(which(w==2)))
}
for(i in 1:1000){
w=walk2(100,seed=i)
p1=c(p1,sum(which(w==0)))
p2=c(p2,sum(which(w==1)))
p3=c(p3,sum(which(w==2)))
}
mean(p1)
mean(p2)
mean(p3)
w=walk2(100,seed=1)
sum(which(w==0))
which(w==0
)
p1=c()
p2=c()
p3=c()
for(i in 1:1000){
w=walk2(100,seed=1)
p1=c(p1,length(which(w==0)))
p2=c(p2,length(which(w==1)))
p3=c(p3,length(which(w==2)))
}
mean(p1)
mean(p2)
mean(p3)
p1=c()
p2=c()
p3=c()
for(i in 1:10000){
w=walk2(1000,seed=1)
p1=c(p1,length(which(w==0)))
p2=c(p2,length(which(w==1)))
p3=c(p3,length(which(w==2)))
}
mean(p1)
mean(p2)
mean(p3)
bodyTT <- '
int x = 0;
int y= -1;
return(wrap(x+y));
'
test`` <- cxxfunction(signature(), #signature is which is our arguments
body = bodyTT,
plugin = "Rcpp")
bodyTT <- '
int x = 0;
int y= -1;
return(wrap(x+y));
'
test<- cxxfunction(signature(), #signature is which is our arguments
body = bodyTT,
plugin = "Rcpp")
library(inline)
bodyTT <- '
int x = 0;
int y= -1;
return(wrap(x+y));
'
test<- cxxfunction(signature(), #signature is which is our arguments
body = bodyTT,
plugin = "Rcpp")
test()
bodyTT <- '
int x = 0;
int y= -1;
srand(23);
return(wrap(rand%100));
'
test<- cxxfunction(signature(), #signature is which is our arguments
body = bodyTT,
plugin = "Rcpp")
bodyTT <- '
int x = 0;
int y= -1;
srand(23);
return(wrap(rand()%100));
'
test<- cxxfunction(signature(), #signature is which is our arguments
body = bodyTT,
plugin = "Rcpp")
test()
bodyTT <- '
int x = 0;
int y= -1;
srand(24);
return(wrap(rand()%100));
'
test<- cxxfunction(signature(), #signature is which is our arguments
body = bodyTT,
plugin = "Rcpp")
test()
bodyTT <- '
int x = 0;
int y= -1;
srand(24);
return(wrap(rand()%2));
'
test<- cxxfunction(signature(), #signature is which is our arguments
body = bodyTT,
plugin = "Rcpp")
test
test()
bodyTT <- '
int x = 0;
int y= -1;
srand(24);
return(wrap(rand()%2));
'
test<- cxxfunction(signature(), #signature is which is our arguments
body = bodyTT,
plugin = "Rcpp")
test()
Rcpp::sourceCpp("ranwalk.cpp")
Rcpp::sourceCpp("ranwalk.cpp")
walk2(20,seed =23)
Rcpp::sourceCpp("ranwalk.cpp")
walk2(20,seed =23)
Rcpp::sourceCpp("ranwalk.cpp")
walk2(5,seed =23)
walk2(10,seed =23)
walk2(10,seed =21)
Rcpp::sourceCpp("ranwalk.cpp")
#This looks like at the walk function
walk(5,seed = 20)
#This looks like at the walk function
walk(5,seed = 20)
Rcpp::sourceCpp("ranwalk.cpp")
yes20 = rep(0,1000) #stores 1 if reached wihin 20 and 0 if not
for(i in 1:1000){
walks = Destination(as.integer(c(1,-3)),20,seed = i)
#
if(TRUE%in%walks){
yes20[i] = 1
}
}
sum(yes20)/1000
Rcpp::sourceCpp("ranwalk.cpp")
yes20 = rep(0,1000) #stores 1 if reached wihin 20 and 0 if not
for(i in 1:1000){
walks = Destination(as.integer(c(1,-3)),20,seed = i)
#
if(TRUE%in%walks){
yes20[i] = 1
}
}
sum(yes20)/1000
yes20 = rep(0,1000) #stores 1 if reached wihin 20 and 0 if not
for(i in 1:1000){
walks = Destination(as.integer(c(1,-3)),20,seed = i)
#
if(TRUE%in%walks){
yes20[i] = 1
}
}
sum(yes20)/1000
yes20 = rep(0,10000) #stores 1 if reached wihin 20 and 0 if not
for(i in 1:10000){
walks = Destination(as.integer(c(1,-3)),20,seed = i)
#
if(TRUE%in%walks){
yes20[i] = 1
}
}
sum(yes20)/10000
Rcpp::sourceCpp("ranwalk.cpp")
yes20 = rep(0,10000) #stores 1 if reached wihin 20 and 0 if not
for(i in 1:10000){
walks = Destination(as.integer(c(1,-3)),20,seed = i)
#
if(TRUE%in%walks){
yes20[i] = 1
}
}
sum(yes20)/10000
#Question 3
#compare the two walk functions
library(rbenchmark)
benchmark(walk(100,seed=23),walk2(100,25),replications(1000),order = "relative")
benchmark(walk(100,seed=23),walk2(100,25),replications(1000),order = "relative")
benchmark(walk(100,seed=23),walk2(100,25),replications(1000),order = "relative")
walk<- function(){
retrun(walk(100,seed=23))
}
walk2<- function(){
retrun(walk2(100,seed=23))
}
benchmark(walk(),walk2(),replications(1000),order = "relative")
walk<- function(){
return(walk(100,seed=23))
}
walk2<- function(){
return(walk2(100,seed=23))
}
benchmark(walk(),walk2(),replications(1000),order = "relative")
alk(100,seed=23)
walk(100,seed=23)
#This looks like at the walk function
walk(5,seed = 20)
Rcpp::sourceCpp("ranwalk.cpp")
walk2(10,seed =21)
#This looks like at the walk function
walk(5,seed = 20)
walk<- function(){
return(walk(100,seed=23))
}
walk2<- function(){
return(walk2(100,seed=23))
}
benchmark(walk(),walk2(),replications(1000),order = "relative")
rwalk<- function(){
return(walk(100,seed=23))
}
rwalk2<- function(){
return(walk2(100,seed=23))
}
benchmark(rwalk(),rwalk2(),replications(1000),order = "relative")
walk(100,seed=23)
walk2(100,seed=23)
#This looks like at the walk function
walk(5,seed = 20)
walk2(10,seed =21)
sourceCpp("ranwalk.cpp")
#This looks like at the walk function
walk(5,seed = 20)
walk2(10,seed =21)
walk(100,seed=23)
walk2(100,seed=23)
rwalk<- function(){
return(walk(100,seed=23))
}
rwalk()
rwalk2<- function(){
return(walk2(100,seed=23))
}
benchmark(rwalk(),rwalk2(),replications(1000),order = "relative")
rwalk<- function(){
m<-walk(100,seed=23)
return(1)
}
rwalk2<- function(){
m <- walk2(100,seed=23)
return(1)
}
benchmark(rwalk(),rwalk2(),replications(1000),order = "relative")
benchmark(rwalk(),rwalk2(),replications(1),order = "relative")
benchmark(rwalk(1),rwalk2(1),replications(1),order = "relative")
rwalk<- function(x){
m<-walk(100,seed=23)
return(x+1)
}
rwalk2<- function(x){
m <- walk2(100,seed=23)
return(x+1)
}
benchmark(rwalk(1),rwalk2(1),replications(1),order = "relative")
#Question 3
#compare the two walk functions
library(rbenchmark)
benchmark(rwalk(1),rwalk2(1),replications(1),order = "relative")
#This looks like at the walk function
walk(5,seed = 20)
walk2(10,seed =21)
alk2(100,seed=23)
walk2(100,seed=23)
walk(100,seed=23)
benchmark(rwalk(1),rwalk2(1),replications(1),order = "relative")
benchmark(rwalk(1),rwalk2(1),replications(100),order = "relative")
benchmark(walk(100,2),walk2(100,2),replications(100),order = "relative")
walk2(100,2)
bodyTT <- '
int x = 0;
int y= -4;
srand(24);
return(wrap(abs(y)));
'
test<- cxxfunction(signature(), #signature is which is our arguments
body = bodyTT,
plugin = "Rcpp")
test()
Rcpp::sourceCpp("ranwalk.cpp")
Rcpp::sourceCpp("ranwalk.cpp")
avgD <- c()
for(i in 1:1000){
avgD<-c(avgD,ManhattanD(50,23))
}
mean(avgD)
mean(avgD) # = 11
Rcpp::sourceCpp("ranwalk.cpp")
int ManhattanD(int n, int seed){  //finds the Manhatan distance after n amount of moves
IntegerMatrix m = walk(n, seed);
int dist =  abs(m(n-1,0))+abs(m(n-1,1));
return(dist);
}
avgD <- c()
for(i in 1:1000){
avgD<-c(avgD,ManhattanD(50,23))
}
mean(avgD) # = 11
avgD <- c()
for(i in 1:100000){
avgD<-c(avgD,ManhattanD(50,23))
}
mean(avgD) # = 11
Rcpp::sourceCpp("ranwalk.cpp")
avgD <- c()
for(i in 1:100000){
avgD<-c(avgD,ManhattanD(50,23))
}
mean(avgD) # = 11
Rcpp::sourceCpp("ranwalk.cpp")
Rcpp::sourceCpp("ranwalk.cpp")
avgD <- c()
for(i in 1:1000){
avgD<-c(avgD,ManhattanD(50))
}
mean(avgD)
es20 = rep(0,1000) #stores 1 if reached wihin 20 and 0 if not
for(i in 1:1000){
walks = Destination(as.integer(c(1,-3)),20,seed = i)
#
if(TRUE%in%walks){
yes20[i] = 1
}
}
sum(yes20)/1000
#Question2
yes20 = rep(0,1000) #stores 1 if reached wihin 20 and 0 if not
for(i in 1:1000){
walks = Destination(as.integer(c(1,-3)),20,seed = i)
#
if(TRUE%in%walks){
yes20[i] = 1
}
}
sum(yes20)/1000
Rcpp::sourceCpp("ranwalk.cpp")
Rcpp::sourceCpp("ranwalk.cpp")
yes20 = rep(0,1000) #stores 1 if reached wihin 20 and 0 if not
for(i in 1:1000){
walks = Destination(as.integer(c(1,-3)),20,seed = i)
#
if(TRUE%in%walks){
yes20[i] = 1
}
}
sum(yes20)/1000
yes20 = rep(0,1000) #stores 1 if reached wihin 20 and 0 if not
for(i in 1:1000){
walks = Destination(as.integer(c(1,-3)),20,seed = i)
#
if(TRUE%in%walks){
yes20[i] = 1
}
}
sum(yes20)/1000
yes20 = rep(0,1000) #stores 1 if reached wihin 20 and 0 if not
for(i in 1:1000){
walks = Destination(as.integer(c(1,-3)),20,seed = i)
#
if(TRUE%in%walks){
yes20[i] = 1
}
}
sum(yes20)/1000
yes20 = rep(0,1000) #stores 1 if reached wihin 20 and 0 if not
for(i in 1:1000){
walks = Destination(as.integer(c(1,-3)),20,seed = i)
#
if(TRUE%in%walks){
yes20[i] = 1
}
}
sum(yes20)/1000
yes20 = rep(0,1000) #stores 1 if reached wihin 20 and 0 if not
for(i in 1:1000){
walks = Destination(as.integer(c(1,-3)),20,seed = i)
#
if(TRUE%in%walks){
yes20[i] = 1
}
}
sum(yes20)/1000
source("~/Masters/CProg/Assig2/RanWalk/randomwalk.R")
Rcpp::sourceCpp("ranwalk.cpp")
#Question 3
#compare the two walk functions
library(rbenchmark)
benchmark(walk(100,2),walk2(100,2),replications(100),order = "relative") #benchmark error this wont work
#going to use sys.time instead
times<-matrix(rep(NA,2000),nrow =1000, ncol =2)
times<-matrix(rep(NA,2000),nrow =1000, ncol =2)
for(j in 1:1000){
s <- sys.time()
x<-walk(1000,j)
e <- sys.time()
times[1,j] <-  e-s
s1 <- sys.time()
x1<-walk2(1000,j)
e1 <- sys.time()
times[2,j] <-  e1-s1
}
source("~/Masters/CProg/Assig2/RanWalk/randomwalk.R")
#going to use sys.time instead
times<-matrix(rep(NA,2000),nrow =1000, ncol =2)
for(j in 1:1000){
s <- Sys.time()
x<-walk(1000,j)
e <- Sys.time()
times[1,j] <-  e-s
s1 <- Sys.time()
x1<-walk2(1000,j)
e1 <- Sys.time()
times[2,j] <-  e1-s1
}
j =1
s <- Sys.time()
x<-walk(1000,j)
e <- Sys.time()
s
e
s-e
f <- s-e
f
f$
time
#-------
library(microbenchmark)
microbenchmark(walk1 = {walk1(1000,2)},walk2 = {walk2(1000,2)})
microbenchmark(walk1 = {walk(1000,2)},walk2 = {walk2(1000,2)})
?microbenchmark
microbenchmark(walk1 = {walk(1000,2)},walk2 = {walk2(1000,2)}, times = 1000L)
microbenchmark(walk1 = {walk(1000,2)},walk2 = {walk2(1000,2)}, times = 100000L)
microbenchmark(walk1 = {walk(10000,2)},walk2 = {walk2(10000,2)}, times = 10000L)
#going to use sys.time instead
times<-matrix(rep(NA,2000),nrow =1000, ncol =2 unit = "seconds")
#going to use sys.time instead
times<-matrix(rep(NA,2000),nrow =1000, ncol =2, unit = "seconds")
#going to use sys.time instead
times<-matrix(rep(NA,2000),nrow =1000, ncol =2, unit = "second")
microbenchmark(walk1 = {walk(10000,2)},walk2 = {walk2(10000,2)}, times = 10000L, unit = "seconds")
microbenchmark(walk1 = {walk(10000,2)},walk2 = {walk2(10000,2)}, times = 10000L, unit = "miliseconds")
microbenchmark(walk1 = {walk(10000,2)},walk2 = {walk2(10000,2)}, times = 10000L, unit = "milliseconds")
microbenchmark(walk1 = {walk(100000,2)},walk2 = {walk2(100000,2)}, times = 1000L, unit = "milliseconds")
benchmark(walk(100,2),walk2(100,2),replications(100),order = "relative")
source("~/Masters/CProg/Assig2/RanWalk/randomwalk.R")
